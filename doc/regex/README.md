# 正则表达式 学习笔记

## 1. 基本概念
- `Regular Expression`使用单个字符来描述、匹配一系列符合某个语法规则的字符串。
- 即为：按照某种规则去匹配符合条件的字符串；  
- [正则表达式在线解析工具](https://regexper.com/)；


## 2. 基本语法
### 2.1 修饰符
修饰符决定了文本的检索模式，加载正则表达式的结尾，可以混合使用多个修饰符。
- `g`：`global`，全文检索，若不添加只匹配到第一个为止；
- `i`：`ignore case`，忽略大小写；
- `m`：`multiline`，多行搜索；
``` javascript
//将每一行以a或b或c结尾的字符替换为x
'a1b2c3d4'.replace(/[abc]$/gm,'x');
```

### 2.2 元字符
正则表示由两种基本字符构成：
- 原义字符：表示字符原来含义的字符；
- 元字符：在正则表达式中有特殊含义的非字母字符；元字符的含义并不唯一；
``` javascript
* + ? $ ^ . | \ ( ) [ ] { }
```
常用元字符：
``` javascript
\t 	//水平制表符
\v	//垂直制表符
\n	//换行符
\r 	//回车符
\0	//空字符
\f 	//换页符
```

### 2.3 字符类
- 使用元字符`[ ]`来构建一个简单类；使用`^`可以将类取反；
- 一般情况下，正则表达式一个字符对应字符串的一个字符，但有时我们希望匹配一系列特征的一类字符；
- 类即为符合某些特征的对象，一个泛指，而不是具体的某个字符；
- 表达式`[abc]`把字符`a`或`b`或`c`归为一类，表达式可以匹配这类的字符；

范例：
``` javascript
//将a,b,c替换为x
'a1b2c3d4'.replace(/[abc]/g,'x');
//将不是a,b,c的字符替换为x
'a1b2c3d4'.replace(/[^abc]/g,'x');
```

### 2.4 范围类
- 使用元字符`-`可以表示一个范围；
- 使用`[a-z]`可以创建一个范围类，表示从a到z的任意字符；
- 这是个闭区间，也就是包含a和z本身；
- 在`[]`组内部是可以连写的，如`[a-zA-Z]`；

范例：
``` javascript
//将a-c的字符替换为Q
'a1b2d3x4z9'.replace(/[a-c]/g, 'Q')
//连写匹配
'a1b2d3x4z9A1B2C3'.replace(/[a-cA-C]/g, 'Q')
```

### 2.5 预定义类
正则表达式中的预定义类：
``` javascript
. 		//除了回车和换行的所有字符
\d		//数字字符(digit)
\D		//非数字字符
\s		//空白字符(space)
\S		//非空白字符
\w		//单词字符(word, 字母/数字/下划线)
\W		//非单词字符
```

### 2.6 边界
正则表达式中的边界：
``` javascript
^		//开始
$		//结束
\b		//单词边界(boundary)	
\B		//非单词边界	
```

范例：
``` javascript
//匹配整个is单词
'this is a boy'.replace(/\bis\b/g, 0)
```

### 2.7 量词
正则表达式中的量词：
``` javascript
?		//出现0次或1次（至多1次）
+       //出现1次或多次（至少1次）
*       //出现0次或多次（任意次）
{n}		//出现n次
{n,m}	//出现n到m次
{n,}	//至少出现n次
```

### 2.8 贪婪模式
- 贪婪模式：默认的模式，会尽可能匹配更多字符；
- 非贪婪模式：在量词后加`?`让正则表达式尽可能更少的匹配，也就是说一旦成功匹配将不再继续尝试；

``` javascript
//贪婪模式 -> "x78"
'12345678'.replace(/\d{3,6}/g, 'x')
//非贪婪模式 -> "xx78"
'12345678'.replace(/\d{3,6}?/g, 'x')
```

### 2.9 分组
- 使用`( )`可以达到分组的功能，使量词用于分组；
- 使用`|` 可以达到或的效果；
- 使用`$`可以反向应用捕获的分组，例如`$1`,`$2`；
- 使用`(?:)`可以忽略分组；

范例：
``` javascript
//字符后面跟一个数字，重复三次  "xd4"
'a1b2c3d4'.replace(/([a-z]\d){3}/g, 'x');
//分组中使用或 "xx"
'ByronsperByrCasper'.replace(/Byr(on|Ca)sper/g, 'x');
//年月日转月日年  "12-25-2015"
'2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2})/g, '$2-$3-$1');
//忽略第一个分组
/(?:\d{4})-(\d{2})-(d2{2})/g
```

### 2.10 前瞻/后顾
- 正则表达式从文本头部向尾部开始解析，文本尾部方向称为“前”；
- 前瞻就在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾相反；
- Javascript不支持后顾；
- 符合和不符合断言称为肯定/正向匹配和否定/负向匹配；断言也是个正则表达式；

基本语法：
``` 
exp(?=assert)		//正向前瞻
exp(?!assert)		//负向前瞻
exp(?<=assert)		//正向后顾
exp(?<!assert)		//负向后顾
```

范例：
```
//替换紧跟一个数字的字符  "x2*3"
'a2*3'.replace(/\w(?=\d)/g, 'x')
//替换不紧跟数字的字符 "ax*axx*"
'a2*a3d*'.replace(/\w(?!\d)/g, 'x')
```


## 3. JavaScript 中的正则表达式
- `JavaScript`通过内置对象`RegExp`支持正则表达式；
- 有两种方法实例化`RegExp`对象

### 3.1 RegExp
#### 3.1.1 构造RegExp对象
字面量：
``` javascript
var reg = /\bis\b/;
```
构造函数：
``` javascript
var reg = new RegExp('\\bis\\b')
```

#### 3.1.2 RegExp对象属性
即为`RegExp`对象的属性，这些属性是标志位，不能需改；
- `global`：是否全文坚守；
- `ignoreCase`：是否大小写敏感；
- `multiline`：多行搜索；
- `lastIndex`：当前表达式匹配内容的最后一个字符的下一个位置；在非全局检索模式下该属性无效；
- `sourec`：正则表达式的文本字符串；

### 3.3 RegExp 常用方法

#### 3.3.1 test
 `regex.test(str)`：测试字符串是否满足正则表达式；
- 若包含`g`标识，每次检测`lastIndex`属性均会指向本次匹配字符的下一个位置；到尾部时会重置为0；
- 若不包含`g`标识，每次检测`lastIndex`都为`0`；

``` javascript
var reg2 = /\w/gim;
reg2.test('asd')	//true
reg2.lastIndex		//1
reg2.test('asd')	//true
reg2.lastIndex		//2
```

#### 3.3.2 exec
`regex.exec(str)`：使用正则表达式对字符串进行搜索；
- 将更新全局`RegExp`对象的属性以反映匹配结果；
- 如果文本没有匹配返回`null`，否则返回一个数组；可以进行循环搜索；
- 返回的第一个参数是匹配的文本，后继参数为各个分组的匹配字符；

范例：
``` javascript
var reg3 = /\d(\w)\d/;
var str = "1a2b3c4d5e";
reg3.exec(str);				//["1a2", "a"] 非全局调用

var reg4 = /\d(\w)\d/g;
reg4.exec(str)				//["1a2", "a"] 全局调用第一次
reg4.exec(str)				//["3c4", "c"] 全局调用第二次
```

### 3.4 String 常用方法
####3.4.1 search
`str.search()`：用于检索字符串中置顶的子字符串，或检索与正则表达式相匹配的子字符串；
- 返回第一个匹配结果的`index`，查找不到就返回`-1`
- 不执行全局匹配，总是忽略`g`标识，总是从开头检索；

范例：
``` javascript
var str = "1a2b3c4d5e";
str.search(/4\w/);		//6
```

####3.4.2 match
`str.match(regex)`：用于匹配字符串；
- 如果没有`g`标识，那么`match()`方法就只能在字符串中执行一次匹配；
- 若果没有找到任何文本，则返回`null`；
- 如果找到匹配的文本，则返回一个数组；
	- 全局调用：返回全部匹配的结果数组；
	- 非全局调用：返回第一个匹配的结果及分组信息的数组；

范例：
``` javascript
var reg5 = /\d(\w)\d/;
var ts ="1a2b3d4e";
ts.match(reg5);			//非全局（匹配字符+分组）：["1a2", "a"]

var reg5 = /\d(\w)\d/g;
ts.match(reg5);			//全局（匹配全部分组）：["1a2", "3d4"]
```

####3.4.3 split
`str.split(regexp)`：可以传入正则表达式进行字符分割，在一些复杂的情况可以使用正则表达式来解决；

范例：
```
var ts = "a1b2c3d4e5";
ts.split(/\d/)				//["a", "b", "c", "d", "e", ""]
```

####3.4.4 replace
`str.replace(regexp)`：可以传入正则表达式进行字符替换，在一些复杂的情况可以使用正则表达式来解决；
`str.replace(regexp， function)`：动态替换；参数为匹配字符串、分组（若干个）、index、原字符串；

范例：
```
var ts = "a1b2c3d4e5";
ts.replace(/\d/, 'x')		//"axb2c3d4e5"
```